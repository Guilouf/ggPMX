---
title: "ggPMX - User guide"
author: "Amine Gassem"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ggPMX: User guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
\clearpage  
```{r load_package, echo=FALSE,warning=FALSE,message=FALSE}
knitr::opts_chunk$set(out.width='100%',warning=FALSE,message=FALSE)

library(ggPMX)
#WORK_DIR <- "../ggpmx_files/inputs"
theophylline <- file.path(system.file(package = "ggPMX"), "testdata", 
                          "theophylline")
WORK_DIR <- file.path(theophylline, "Monolix")
input_file <- file.path(theophylline, "data_pk.csv")


```

# Introduction

This document serves as the main overview of the `ggPMX` package. It explains the hows and whys of the design decisions using clear examples.


# Basic workflow

- Generate inputs files for ggPMX package and store them in the same location.
- Create a controller: this object contains a number of different data sets , plots and other object like report settings and default plot settings.
- Use the controller (populated with different plots and other objects) to create custom reports.
- (Optional) Use `set_plot` to generate new plots.
- (Optional) Use `pmx_update` to modify the controller objects: plots/data sets.
- (Optional) Use `pmx_filter` to filter data stored in the controller object.

# The controller

A diagnostic session starts by creating controller using `pmx`. The controller is a general container that defines data configuration but may also contain generated objects like plots and tables. The `pmx` takes a `configuration` as one of its arguments.
A set of pre-built configurations can be listed using :

```{r list_configs}
configs()
```

Then we can instantiate a **standing** (the name of the config) controller using:
```{r init_controller}
ctr <- pmx(
  config = "standing", sys = "mlx", 
           directory = WORK_DIR, 
           input = input_file, dv = "Y", 
           dvid ="DVID")
```

This is can be simplified by setting a number of global options and using the
Monolix controller:

- Setting the working directory using ggPMX options at the begining of the session. It is good practice in general to set global variables at the begining of the session.
- Using the MONOLIX controller.

```{r init_work_dir}
ctr <- pmx_mlx(
  config = "standing", 
           directory = WORK_DIR, 
           input = input_file, dv = "Y", 
           dvid ="DVID")

```


# Source

Behind the scene, when the controller is initialized it will create a source containing all data sets. The source is configured using a configuration object. In the previous example, we just gave the name of the configuration. `ggPMX` will use this name to guess the full path of the configuration file and load the corresponding data sets.

## Source configuration file

Source configuration are `yaml` files. `ymal` is human readable format. This is standard way to set configuration files and it is used in many popular R packages (`rmarkdown`, `htmlwidgets`). This is also the way the DESCRIPTION file of a package is defined. 

Basically, a source is a list of data sets. Each data set may contain one of the following fileds: 

- **label** : The name of the data set. This is can be helpful in the reporting.
- **file**  : the name of the file where to extract data
- **names**(Optional) : key value format of the columns/variable names. We can also set names as a character vector to set all column names.
- **reader**(Optional): In case of complex file, a custom reader function should be provided to tell the parser how to load the file. For the moment, only internal function can be used. This feature should be extended to allow advanced users to define their custom parser.

Here an example of yaml configuration used to read the model predictions of MONOLIX.
We indicate :

- The file name 
- The custom reader used to read this special file 
- The names to do the mapping between  MONOLIX/ggPMX naming conventions. Note that upper-case names for variables are used by convention within ggPMX package.

```{r, eval=FALSE}
    label : model predictions
    file  : MLX_predictions.txt
    reader  : read_mlx_pred
    names:
      id: ID
      time: TIME
      y1: DV
      poppred: PRED
      npde: NPDE
```



## Load the configuration

In practice there is no need to load the configuration. This is done internally within the controller. In some cases it can be interesting to load the configuration and modify some attributes like columns names for example:

```{r load_conf}

conf <- load_config("standing", sys = "mlx")
conf

```

`conf` is a list containing a the configuration of each data set and plots. 
We can change this configuration object by accessing the object as a list object. 

For example to change the mapping from `c("time","TIME")` to `c("time1","TIME")` We can do something like :
```{r change_mapping}

conf$data$mod_pred$names$time <- NULL
conf$data$mod_pred$names$time1 <- "TIME"

```

We will make this easier in next versions by defining wrappers function within the controller.  


```{r change_mapping_future, eval=FALSE}

# The following does not run - TODO: Fix it
#ctr %>% rename("time","time1")
#ctr %>% rename("mod_pred","time","time1")

```

# Plots

The `ggPMX` package allows a number of different plotting types to be
specified by the user. Currently these include the `Distribution plot`, the
`Individual plot` and the `Residual plot`.

In the following sections it will be assummed that appropriate global options 
have been set for the working directory, input file etc. and that a 
suitable controller has been defined. For users looking to replicate plots
a set up as follows can be assummed:

```{r, eval=FALSE}
library(ggPMX)
ctr <- pmx_mlx(config = "standing")

```


## Graphical parameters 

Graphical parameters in `ggPMX` are set internally using the `pmx_gpar` function. A number of graphical paramters can be set for the different
plot types. 

```{r pmx_gpar_args}
args(pmx_gpar)
```
More information can be found in the help document `?pmx_gpar` and in the 
examples that follow.

## Plot types

### Distribution plot

The `Distribution plot` plots the EBE distribution.

```{r , distribut,  fig.width=7, fig.height=6, warning=FALSE,message=FALSE}

ctr %>% set_plot("DIS", pname = "distr1", type = "box")

ctr %>% get_plot("distr1")

```

### Individual plot

```{r , individual_plot,  fig.width=7, fig.height=6, warning=FALSE,message=FALSE}
ctr %>% set_plot("IND", pname = "indiv1", 
                 draft = list(size = 10, label = "DRAFT", color = "grey50"))

ctr %>% get_plot("indiv1", 2)

```


### Residual plot

The `Residual plot` plots a residual Y versus an independant variable X.
Examples of such are NPD vs EPRED, NPD vs TIME etc. 

```{r , residual_plot,  fig.width=7, fig.height=6,message=FALSE}
ctr %>% set_plot("RES", pname = "res1", y = "IWRES", x = "IPRED")

ctr %>% get_plot("res1")

```

# Complete example

In this section we introduce a complete example that illustrates the
workflow using the `ggPMX` package. Steps taken include: 

- Initializing the working dir and related quantities
- Creating the controller using the **standing** configuration
- Adding a new plot
- Printing all the plots


```{r complete_example, warning=FALSE,  fig.width=7, fig.height=6}
library(ggPMX)

## define a working dir
# Example that points to file in user's work directory
# Commented because the vignette will not build if it is on:
# pmxOptions(work_dir="/home/agstudy/projects/r/ggPMX/ggPMX_files/inputs")

ctr <- pmx(
  config = "standing", sys = "mlx", 
           directory = WORK_DIR, 
           input = input_file, dv = "Y", 
           dvid ="DVID")


## add a new plot
ctr %>%
   set_plot(ptype="DIS",
            pname="distri_box",
            type="box",
            has.shrink=FALSE,
            has.jitter=FALSE)

## update individual plots draft argument
ctr %>% pmx_update("indiv", 
                   draft = list(size = 10, label = "DRAFT", 
                                color = "grey50"))

## return all plots
lapply(ctr %>% plot_names,
       function(x){
        if(x=="indiv") return(ctr%>%get_plot(x, c(2)))
         ctr %>% get_plot(x)
       })



```




# Additional considerations

## Updating plots

Plots can be updated using the `pmx_update` function. As an illustration compare the residual plot produced previously with an updated version:

```{r update_plot,  fig.width=7, fig.height=6}

library(ggPMX)

ctr %>% set_plot("RES", pname = "res1", y = "IWRES", x = "IPRED")

p1 <- ctr %>% get_plot("res1")

# remove bands
p2 <- ctr %>% 
  pmx_update("res1", has.band = FALSE, 
             labels = list(title = "IPRED versus IWRES (no bands)")) %>% 
  get_plot("res1")

p1
p2
```


## Filtering data

### Global filtering

The `pmx_filter` function allows a user to globally filter a named data set.
Here we filter on the condition that ID is less than or equal to five:

```{r pmx_filter,  fig.width=7, fig.height=6}
plotnames <- ctr %>% plot_names()
ctr %>% 
  pmx_filter(data_set = "predictions", ID <= 5) %>% 
  get_plot(plotnames[1])
  

```

### Local filtering

An alternative to globally filtering the data for all plots is to apply
filtered data for a given plot. This can be done in one of two ways; 
via the `set_plot` function or using the `pmx_update` function. 

#### set_plot

With `set_plot` the intention is to create a brand new plot rather than
ammending an existing one. For illustration we set the distribution plot
shown earlier as a fresh plot:

```{r local_filter_set_plot}

ctr <- pmx(
  config = "standing", sys = "mlx", 
           directory = WORK_DIR, 
           input = input_file, dv = "Y", 
           dvid ="DVID")
ctr %>% set_plot("DIS", pname = "distr1", type = "box")
p <- ctr %>% get_plot("distr1")
pconf <- ggplot2::ggplot_build(p)
dim(pconf$data[[2]])
```
We can see that with the unfiltered data set we have 150 observations.
Filtering the `ID` field so that we remove any ID's greater than 10:

```{r local_filter_set_plot2,  fig.width=7, fig.height=6}

ctr %>% set_plot("DIS", pname = "distr2", filter = ID < 10, type = "box")
p <- ctr %>% get_plot("distr2")
p
pconf <- ggplot2::ggplot_build(p)
dim(pconf$data[[2]])
```

we observe the effect of filtering on the ID both graphical comparing the above plot with the one produced previously and numerical looking at the new 
dimensions of the data plotted.

#### pmx_update

The `pmx_update` can also take a filter expression to update a plot. 
First lets work with the previous plot produced in the last section 
`distr2`. Firstly lets reset the filter:

```{r local_filter_pmx_update_reset,  fig.width=7, fig.height=6}
ctr %>% pmx_update("distr2", filter = NULL)
p <- ctr %>% get_plot("distr2")
p
pconf <- ggplot2::ggplot_build(p)
dim(pconf$data[[2]])
```

now as in the `set_plot` example we can apply a filter in a similiar manner:

```{r local_filter_pmx_update_filter,  fig.width=7, fig.height=6}
ctr %>% pmx_update("distr2", filter = ID < 10)
p <- ctr %>% get_plot("distr2")
pconf <- ggplot2::ggplot_build(p)
dim(pconf$data[[2]])
```

## Shrinkage

The `shrinkage` function allows $\eta$-shrinkage to be calculated using the parameter and individual estimation data. $\eta$-shrinkage is calculated as \[
1-SD(\eta)/\omega 
\]
where $\eta$ are the between individual variation terms and $\omega$ is the population model estimate of the standard deviation in $\eta$. As an example we
can calculate the shrinkage using the theophyline test data:

```{r shrinkage}


ctr <- pmx(
  config = "standing", sys = "mlx", 
           directory = WORK_DIR, 
           input = input_file, dv = "Y", 
           dvid ="DVID")

estimates <- ctr %>% get_data("estimates")
eta <- ctr %>% get_data("eta")
shrinkage_estimates <- shrinkage(estimates, eta)
knitr::kable(shrinkage_estimates,align = "c",caption="Shrinkagee result",digits = 2)
```
