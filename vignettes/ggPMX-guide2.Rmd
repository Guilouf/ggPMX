---
title: "ggPMX - User guide"
author: "Amine Gassem"
date: '`r Sys.Date()`'
output: 
  pdf_document:
    keep_tex: yes
    number_sections: yes
    toc: yes
vignette: >
  %\VignetteIndexEntry{ggPMX: User guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
\clearpage  
```{r load_package, echo=FALSE,warning=FALSE,message=FALSE}
knitr::opts_chunk$set(out.width='100%',warning=FALSE,message=FALSE)
library(ggPMX)
```



# Introduction

The `ggPMX` package generates standard model diagnostic plots and tables used in PMX activities.

The package aims to automate plot and report generation. 

This vignette introduces the ggPMX syntax, how to initialize a controller using package data , display plots, update existing plots , filter data , stratification and many others details. 

# Architecture
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('./ggPMX_arch.png')
```


# Plots table

The main target of ggPMX is to create a report containing the following plots: 

```{r plots_list,echo=FALSE}

out <- rbind(
  c("Plot of weighted residuals versus population predictions","RES","npde_pred"),
  c("Plot of weighted residuals versus time","RES","npde_time"),
  c("Plot of IWRES versus time","RES","iwres_time"),
  c("Plot of observations versus population predictions", "RES","dv_pred"),
  c("Plot of observations versus individual predictions", "RES","dv_ipred"),
  c("Plot of absolute individual weighted residuals versus individual predictions","RES","abs_iwres_ipred"),
  c("Plot of individual weighted residuals (IWRES) versus individual predictions","RES","iwres_ipred"),
  c("Plots of observations and model predictions per individual","IND","indiv"),
  c("Distribution of EBE histogram","DIS","ebe_hist"),
  c("Distribution of EBE boxplot","DIS","ebe_box"),
  c("Distribution and quantile-quantile plot of IWRES","QQ","qq_iwres"),
  c("Distribution and correlation structure (ETA)","ETA_PAIRS","eta_matrix"),
  c("Relationships between (ETA) and categorical covariates","ETA_COV","eta_cats"),
  c("Relationships between (ETA) and continuous covariates","ETA_COV","eta_conts"),
  c("Visual predictive check (VPC)","VPC","vpc"))

colnames(out) <- c("Plot Name","ggPMX type","ggPMX name")
knitr::kable(out)
```




# Package data 

In order to present the package features , the package comes with built in data. 
This vignette, we will use theophylline data. 
*PS: (TODO add some description of the data here, PK case,...)*


# ggpMX: basics

## theophylline controller
Within `ggPMX`, the first thing to do is to create a controller. 
To create a controller using `theophylline` data we call the helper function:

```{r theophylline_ctr}
ctr <- theophylline()
```
Let's discover the controller content by printing to the console:
```{r display_ctr}
print(ctr)
```
We get mainly 3 tables:

- Table of the controller configuration 
- Table of data sets
- Table of plots. 

**Note that**:

* We will go in depth through the controller construction details when we create a controller using custom data.
* The ctr is an object of class `r class(ctr)[1]`. It behaves like a container that stores: 
+ data configuration, 
+ plots configuration
+ data sets
+ plots
+ templates path.
+ report

## Get Plots

The controller is a container that stores all plots. To get the list of plots:

```{r plot_lists}
ctr %>% plot_names
```
Note here the use of piping 

To view a particular plot we call `get_plot` with the name of the plot:
```{r get_ipred_iwres}
ctr %>% get_plot("iwres_ipred")
```


In case of individual plots, We can pass in addition the number of page to plot to `get_plot`:

```{r ind_plots}
ctr %>% get_plot("indiv",npage = 2)
```

`get_plot` returns a standard `ggplot2` object that you can customize using any valid `ggplot2` operation. Here for example we are combining 2 versions of the distribution plot:

```{r ebe_plots, out.width='.49\\linewidth', fig.width=3, fig.height=3,fig.show='hold',fig.align='center'}
ctr %>% get_plot("ebe_hist")
ctr %>% get_plot("ebe_box")
```

## Get data

In the previous example, `ggPMX` controller reads modeling input and output data files. We can access any data set using the `get_data` function. 

The controller reads andd reshapes the follwing data:

- **input**: Modeling input data 
- **estimates**: Estimated population parameters
- **predictions**: Model output at the level of individual observations and subjects. 
- **eta**: Parameter estimates, and in particular SD of random effects and residual errors (to calculate shrinkage)
- **finegrid** (ONLY for MONOLIX): Aggregate all finegrid.txt files to be merged with covariate


### Modelling input data
```{r get_input_data}
ctr %>% get_data("input")
```

### Model output data
```{r get_outputs_data}
ctr %>% get_data("estimates")
ctr %>% get_data("predictions")
ctr %>% get_data("eta")
ctr %>% get_data("finegrid")
```

**Note that**

`ggPMX` uses `data.table` package to load data and reformat variables names. Manipulating and reshaping data is very efficient and  very intuitive.  Here an example of filtering input data in a sugar syntax manner. 

```{r dx_sugar_syntax}

input <- ctr %>% get_data("input")
input[DV>350 & TIME>0  & ID==1 & SEX==1]

```

# User custom data

## Init controller 

A diagnostic session starts by creating controller using `pmx` or one of its wrapper functions like `pmx_mlx`. Here an example where we instantiate a **standing** (the name of the config) controller:

```{r init_ctr}

theophylline <- file.path(system.file(package = "ggPMX"), "testdata", 
                          "theophylline")
WORK_DIR <- file.path(theophylline, "Monolix")
input_file <- file.path(theophylline, "data_pk.csv")

ctr <- pmx(
  sys="mlx",
  config = "standing", 
  directory = WORK_DIR, 
  input = input_file, 
  dv = "Y", 
  dvid ="DVID")

```

Here we set all **mandatory** arguments:

- sys : Modeling sytem can be MONOLIX or NONMEM
- config : Configuration used.
- directory: Working directory path where we have the model output files
- input: Modeling input file complete path
- dv : Measurable variable name
- dvid : Endpoint type name 

## Controller with covariates

Besides the mandatory fields to initialize a controller, user can set optional parameters related to covariates 

```{r init_ctr_covar}
ctr <- pmx_mlx(
  config = "standing", 
  directory = WORK_DIR, 
  input = input_file, 
  dv = "Y", 
  dvid ="DVID",
  cats=c("SEX"),
  conts=c("WT0","AGE0"),
  strats="STUD")

```

We can access different covariates using helpers functions:

```{r get_covar}
ctr %>% get_cats
ctr %>% get_conts
ctr %>% get_strats
ctr %>% get_covariates
```

## Plot types

`ggPMX` comes with a list of plot types. This is not to be confused with plot names. 
```{r plot_types}
ctr %>% plots
```

+ **RES** : residual plots
+ **IND** : individual plots
+ **DIS** : Distribution of EBE histogram and boxplot
+ **ETA_PAIRS**: ETA Distribution and correlation structure
+ **ETA_COV**: Relationships between ETA and continuous or categorical covaraites

Each plot type can be used to create one or many plots. 


## Update existing plot

Plots can be updated using the `pmx_update` function. As an illustration compare the residual plot produced previously with an updated version:

```{r update_res_plot,  out.width='.49\\linewidth', fig.width=4, fig.height=3,fig.show='hold',fig.align='left'}

library(ggPMX)

ctr %>% set_plot("RES", pname = "res1", y = "IWRES", x = "IPRED")

p1 <- ctr %>% get_plot("res1")

# remove bands
p2 <- ctr %>% 
  pmx_update("res1", has.band = FALSE, 
             labels = list(title = "IPRED versus IWRES (no bands)")) %>% 
  get_plot("res1")

p1
p2
```


## Create a new plot 
To create a new plot we use `set_plot` function. We set :

+ The plot type
+ the plot name
+ the plot type specific parameters

### New residual plot
```{r new_res_plot}
ctr %>% 
  set_plot("RES", pname = "pred_vs_time",x="TIME",y="PRED")%>% 
  get_plot( "pred_vs_time")

```
see `??residual` for the list of all parameters to create a new residual plot.

### New distribution plot
```{r new_dis_plot}
ctr %>% 
  set_plot("DIS", pname = "distr1", type = "box",has.jitter=FALSE) %>%
  get_plot("distr1")
```
see `?distib` for the list of all parameters to create a new individual plot.

### New individual plot
```{r new_ind_plot}
ctr %>% 
  set_plot("IND", pname = "ind1") %>%
  get_plot("ind1",4) #" get the fourth page


```
see `??individual` for the list of all parameters to create a new individual plot.





# ggPMX graphical parameters 

Graphical parameters in `ggPMX` are set internally using the `pmx_gpar` function. A number of graphical paramters can be set for the different plot types. 

```{r pmx_gpar_args}
args(pmx_gpar)
```
More information can be found in the help document `?pmx_gpar` and in the 
examples that follow.


# ggPMX main functions

`ggPMX` implements few functions to generate and manipulate diagnostic plots. 

1. `pmx` , `pmx_mlx` to create a controller.
2. `plot_names`,`plots` to list controller plots.
3. `get_data` to list controller data.
3. `get_plot` to print a plot.
4. `set_plot` to create a new plot.
5. `pmx_update` to update an existing plot.
6. `pmx_filter` To filter globally session data.
7. `pmx_copy` to get a deep copy of the controller

The design of the package is around the central object: the controller. that we can introspect or pipe it using the `%>%`. 

**Note that**:

The controller is an `R6` object, it behaves like a reference object.  Some functions ( methods) can have a side effect on the controller and modify it internally. Technically speaking we talk about chaining not piping here. However , using `pmx_copy` user can work on a copy of the controller.

\clearpage 

# appendix A: All Theophylline plots

Here the list of all plots based on theophylline data set. 

## Residual plots
```{r th_plots_res, out.width='.49\\linewidth', fig.width=4, fig.height=3,fig.show='hold',fig.align='left',message=FALSE}
## helper function to print plot by type 
pmx_plot_type <- function(type){
  yy <- ctr %>% plots
  plot_names <-yy[yy$plot_type==type][["plot_name"]]
  invisible(lapply(plot_names,function(x)print(ctr %>% get_plot(x))))
}


pmx_plot_type("RES")
```

## Individual plots
```{r th_plots_ind, out.width='.49\\linewidth', fig.width=4, fig.height=3,fig.show='hold',fig.align='left',message=FALSE}

yy <- ctr %>% plots
plots_pages <- ctr %>% get_plot("indiv")
invisible(lapply(plots_pages, print))
```

## Distribution plots
```{r th_plots_dis, out.width='.49\\linewidth', fig.width=4, fig.height=3,fig.show='hold',fig.align='left',message=FALSE}
pmx_plot_type("DIS")
```

## QQ plots
```{r th_plots_qq, out.width='.49\\linewidth', fig.width=4, fig.height=3,fig.show='hold',fig.align='left',message=FALSE}
pmx_plot_type("PMX_QQ")
```

## EBE plots

### Distribution and correlation structure of estimated inter-individual random effects (ETA)

```{r th_plots_ebe1, message=FALSE}
pmx_plot_type("ETA_PAIRS")

```

### Relationships between estimated inter-individual random effects (ETA) and covariates

```{r th_plots_ebe2,  out.width='.49\\linewidth', fig.width=4, fig.height=3,fig.show='hold',fig.align='left',message=FALSE}

pmx_plot_type("ETA_COV")
```

